<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>プログラミングII演習課題の手引き 5_5_letter_histogram</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href=".README.css" />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">プログラミングII演習課題の手引き<br />
5_5_letter_histogram</h1>
</header>
<h1 data-number="1" id="説明"><span
class="header-section-number">1</span> 説明</h1>
<p>動的メモリ確保を練習する課題である．</p>
<p>入力された文字列中の大文字と小文字の出現回数を出力せよ．出現回数を格納する配列を<code>malloc</code>関数を使って動的に確保し，使い終わった配列は<code>free</code>関数を使って解放せよ．</p>
<p>固定長の配列や可変長配列を使っても書けるが，動的に確保した配列に出現回数を格納すること．固定長の配列や可変長配列に出現回数を格納している場合は減点する．</p>
<p> <strong>入力：</strong></p>
<ul>
<li><p>標準入力には検索対象の空白と改行を含む文字列が与えられる．</p></li>
<li><p>文字数と行数は不定（ただし<code>MAX_INT</code>文字以下）．</p></li>
</ul>
<p> <strong>出力：</strong></p>
<ul>
<li><p>1行目に英大文字の先頭10文字（A-J）の出現回数を出力する．</p>
<p>2行目に英大文字の続く10文字（K-T）の出現回数を出力する．</p>
<p>3行目に英大文字の最後の6文字（U-Z）の出現回数を出力する．</p>
<p>4行目に小文字の先頭10文字（a-j）の出現回数を出力する．</p>
<p>5行目に小文字の続く10文字（k-t）の出現回数を出力する．</p>
<p>6行目に小文字の最後の6文字（u-z）の出現回数を出力する．</p></li>
<li><p>1行目の例を示す.この例はAが5回，Bが4回のように出力している．なお（半角）空白文字を␣で表しているが，作成するプログラムでは通常の空白でよい．</p>
<pre><code>  A␣␣␣␣␣5␣B␣␣␣␣␣4␣C␣␣␣␣␣3␣D␣␣␣␣␣2␣E␣␣␣␣␣2␣F␣␣␣␣␣0␣G␣␣␣␣␣0␣H␣␣␣␣␣0␣I␣␣␣␣␣0␣J␣␣␣␣␣0</code></pre>
<p><code>printf</code>で出力する場合，1文字分の出現回数の書式指定を<code>"%c %5d"</code>とする．例えばAが5回出現しているなら<code>"A␣␣␣␣␣5"</code>．次の文字との間には空白文字を入れる．</p>
<p>出力末尾に余計な空白があっても構わない．</p></li>
</ul>
<p> <strong>コンパイル：</strong></p>
<pre><code>    $ gcc -Wall -o letter_histogram letter_histogram.c</code></pre>
<p> <strong>実行時の注意：</strong></p>
<p>入力を終える際は，<code>Enter</code>キーの後に<code>Ctrl+D</code>（<code>Ctrl</code>キーを押したまま<code>D</code>キー）を押す（EOF）．<code>Ctrl+D</code>で入力が終わるのは行の先頭だけ．</p>
<h1 data-number="2" id="testlist"><span
class="header-section-number">2</span> テスト一覧</h1>
<p>テスト番号: 1, 2, 3, 4, 5</p>
<p>（1行が長い場合にブラウザでは複数行に分けて表示される場合あるので注意すること）</p>
<p><strong>テスト1</strong></p>
<p>コマンドライン</p>
<pre><code>$ ./letter_histogram</code></pre>
<p>入力</p>
<pre><code>ABCDE ABCDE AAA BB C 01234
abcde fghij klmno pqrst uvwxy z</code></pre>
<p>出力</p>
<pre><code>A     5 B     4 C     3 D     2 E     2 F     0 G     0 H     0 I     0 J     0
K     0 L     0 M     0 N     0 O     0 P     0 Q     0 R     0 S     0 T     0
U     0 V     0 W     0 X     0 Y     0 Z     0 
a     1 b     1 c     1 d     1 e     1 f     1 g     1 h     1 i     1 j     1
k     1 l     1 m     1 n     1 o     1 p     1 q     1 r     1 s     1 t     1
u     1 v     1 w     1 x     1 y     1 z     1 </code></pre>
<p><strong>テスト2</strong></p>
<p>コマンドライン</p>
<pre><code>$ ./letter_histogram</code></pre>
<p>入力</p>
<pre><code>dpMhhyPmc yI DT iJUXpNfh RpV PPWJGvcE nuUB jqYjBrPqs
cS ysO rDE eRiZNQS YjwrGKI Ujg
OeurKNK zTSGVHej SxR iDmueNb</code></pre>
<p>出力</p>
<pre><code>A     0 B     2 C     0 D     3 E     2 F     0 G     3 H     1 I     2 J     2
K     3 L     0 M     1 N     4 O     2 P     4 Q     1 R     3 S     4 T     2
U     3 V     2 W     1 X     1 Y     2 Z     1 
a     0 b     1 c     3 d     1 e     4 f     1 g     1 h     3 i     3 j     5
k     0 l     0 m     2 n     1 o     0 p     3 q     2 r     4 s     2 t     0
u     3 v     1 w     1 x     1 y     3 z     1 </code></pre>
<p><strong>テスト3</strong></p>
<p>コマンドライン（入力量が多いためファイルから与える）</p>
<pre><code>$ ./letter_histogram &lt; tests/3.in</code></pre>
<p>入力</p>
<pre><code>YjbiSz VdGaIJ
kJSJQNxNX YoPZY Rwe
FX zUUCazG lttNJ dVeNwI ZMEyXkOmg XGHW VBHJ
MkcR LdZT KHO LI InoJhFI
Yo JKSBedv CEgYo xvulXS pIIC wFj Lw
5行目以降省略（8行）</code></pre>
<p>入力の全体は <code>cat tests/3.in</code>
コマンドを実行すると表示される．</p>
<p>出力</p>
<pre><code>A     0 B     3 C     3 D     3 E     5 F     4 G     5 H     3 I     7 J     9
K     3 L     4 M     7 N     6 O     2 P     2 Q     2 R     3 S     5 T     4
U     2 V     3 W     3 X     9 Y     6 Z     4 
a     3 b     2 c     2 d     7 e     5 f     2 g     6 h     2 i     2 j     3
k     5 l     2 m     2 n     3 o     5 p     3 q     4 r     0 s     3 t     6
u     2 v     3 w     5 x     6 y     2 z     4 </code></pre>
<p><strong>テスト4</strong></p>
<p>コマンドライン（入力量が多いためファイルから与える）</p>
<pre><code>$ ./letter_histogram &lt; tests/4.in</code></pre>
<p>入力</p>
<pre><code>[\]^_
{|}~
 !&quot;#$&#39;&lt;&gt;*+,/
0123456789
:;&lt;=&gt;?@
5行目以降省略（17行）</code></pre>
<p>入力の全体は <code>cat tests/4.in</code>
コマンドを実行すると表示される．</p>
<p>出力</p>
<pre><code>A     0 B     0 C     0 D     0 E     0 F     0 G     0 H     0 I     0 J     0
K     0 L     0 M     0 N     0 O     0 P     0 Q     0 R     0 S     0 T     0
U     0 V     0 W     0 X     0 Y     0 Z     0 
a     0 b     0 c     0 d     0 e     0 f     0 g     0 h     0 i     0 j     0
k     0 l     0 m     0 n     0 o     0 p     0 q     0 r     0 s     0 t     0
u     0 v     0 w     0 x     0 y     0 z     0 </code></pre>
<p><strong>テスト5</strong></p>
<p>コマンドライン（入力量が多いためファイルから与える）</p>
<pre><code>$ ./letter_histogram &lt; tests/5.in</code></pre>
<p>入力</p>
<pre><code>THE TRAGEDY OF ROMEO AND JULIET

by William Shakespeare


5行目以降省略（3753行）</code></pre>
<p>入力の全体は <code>cat tests/5.in</code>
コマンドを実行すると表示される．</p>
<p>出力</p>
<pre><code>A   635 B   354 C   376 D   189 E   475 F   247 G   183 H   270 I  1053 J   211
K    22 L   241 M   414 N   353 O   470 P   256 Q     3 R   574 S   446 T   805
U    91 V    63 W   453 X     6 Y   129 Z     2 
a  7583 b  1444 c  1869 d  3797 e 12160 f  1864 g  1686 h  6662 i  5832 j    75
k   832 l  4627 m  3083 n  6201 o  8262 p  1328 q    62 r  6084 s  6292 t  8818
u  3527 v  1012 w  2146 x   131 y  2525 z    31 </code></pre>
<h1 data-number="3" id="配布ファイル"><span
class="header-section-number">3</span> 配布ファイル</h1>
<p>ファイル名: letter_histogram.c</p>
<pre><code>/**

氏名: 

学生番号: 

作成日: 

入出力の説明: 

動きの説明: 

感想: 

*/
#include &lt;stdio.h&gt;

int main(int argc, char* argv[]) {
  char c;

  while ((c = getchar()) != EOF) {  // EOFはファイル末尾
    putchar(c); // 不要なら削除せよ
    malloc(1000000); // 1文字読むたびに無駄な1MBメモリを確保する．不要なので削除せよ
  }
  return 0;
}</code></pre>
<h1 data-number="4" id="ヒント"><span
class="header-section-number">4</span> ヒント</h1>
<ul>
<li><p>Cの絵本
メモリ確保とポインタの活用(1)．明快入門Cには<code>malloc</code>関数の記載なし．</p></li>
<li><p>標準入力の末尾（<code>EOF</code>;
end-of-file）については，明快入門C 43 文字入出力2 連続文字入力<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>．</p>
<p>配布ファイルは<code>getchar()</code>関数で標準入力から1文字ずつ読み込み，その文字を<code>putchar()</code>関数で出力している．標準入力の末尾（<code>EOF</code>;
end-of-file）に達すると<code>while</code>文の繰り返しを終わる．不要な部分を削除して使いなさい．</p>
<pre><code>char c; // int型でもよい
while ((c = getchar()) != EOF) {
  // 文字cに対する処理
}</code></pre>
<p>配布ファイルに対して実行例1を入力すると次のように出力される．なお，行末の<code>&lt;Enter&gt;</code>や<code>&lt;Ctrl+D&gt;</code>はそのキーを入力したことを表している．</p>
<pre><code>  $ ./letter_histogram
  ABCDE ABCDE AAA BB C 01234 Z&lt;Enter&gt;
  ABCDE ABCDE AAA BB C 01234 Z
  abcde fghij klmno pqrst uvwxy zz&lt;Enter&gt;
  abcde fghij klmno pqrst uvwxy zz
  &lt;Ctrl+D&gt;
  $ </code></pre></li>
<li><p>動的メモリ確保（<code>malloc</code>関数と<code>free</code>関数）の練習なので．大文字の文字数を数える配列<code>int ucount[26];</code>を宣言する代わりに，次のように配列のメモリ領域を確保する．配列<code>ucount</code>を使い終わったら，<code>free</code>関数でメモリを解放する．<code>malloc</code>関数は<code>stdlib.h</code>ヘッダファイルで宣言されている
<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>．</p>
<pre><code>int *ucount;
ucount = (int *) malloc(26 * sizeof(int));
if (ucount == NULL) {
  fprintf(stderr, &quot;Can not allocate memory\n&quot;);
  return 1;
}
// ucount[0]からucount[25]までのint型配列．
// ucount配列の各要素を0に初期化する．
// ucount配列を使って，出現回数を数える．
free(ucount);</code></pre></li>
<li><p><code>malloc</code>関数で確保したメモリ領域は<code>main</code>関数を終了するときに自動的に解放されるのでプログラム終了後にPCの不調が続くようなことはない．ただし，プログラムを終了するまで無駄にメモリ領域を確保しておく必要はないので，<code>free</code>関数でメモリを解放する練習をこの課題ですること．</p></li>
<li><p>メモリを確保したまま解放しないプログラムの例を示す．次のプログラムは
while文の1回の繰り返しごとに100KBのメモリを確保する．<code>malloc</code>を百回繰り返した後は10MBのメモリが確保されるだけだが，十万回繰り返すと10GB
のメモリが確保される．Windowsのリソースモニタでメモリを確認しながら動かしてみると確保されているメモリ量と十万回繰り返すのにさほど時間がかからないことがわかる．Cygwinターミナルで実行中のプログラムを強制終了するにはCtrl+Cキーを押す．(<code>..._badExample.c</code>)</p>
<pre><code>#include &lt;stdlib.h&gt;

int main() {
  while (1) {
    malloc(100000);
  }
}</code></pre></li>
<li><p><code>malloc</code>関数で確保した配列<code>ucount</code>の各要素は初期化されてないので注意すること．初期化されていないとは，値が不定ということで，実行によって値が変わりうる．配列<code>ucount[N_ALPHABET]</code>のすべての要素を0に初期化する例を示す．</p>
<pre><code>int i;
for (i = 0; i &lt; 26; i++)
  ucount[i] = 0;</code></pre></li>
<li><p>配列<code>ucount[26]</code>で英大文字の出現回数を数えるとする．<code>A</code>の出現回数を
<code>ucount[0]</code>に，<code>B</code>の出現回数を<code>ucount[1]</code>に，<span
class="math inline">\(\ldots\)</span>，<code>Z</code>の出現回数を<code>ucount[25]</code>に格納する場合の例を示す．<code>char</code>型の変数<code>c</code>に英大文字が代入されているとき，次のようにすると<code>c</code>に格納された文字の出現回数が1増える．</p>
<pre><code>ucount[c - &#39;A&#39;]++;</code></pre></li>
<li><p>英小文字についても同様．英小文字の出現回数を数える配列の名前は適当に考えよう．ちなみに<code>ucount</code>の<code>u</code>は，それぞれuppercaseの頭文字からとった．</p></li>
<li><p><code>malloc</code>関数の使い方がわからない人は，一旦<code>int ucount[26];</code>を宣言してプログラムを作り，<code>malloc</code>関数を使ってこの配列のメモリを確保するプログラムに書き換えるという方針がよいだろう．</p></li>
<li><p>英字の文字数26を様々なところで使うので，次のように<code>#define</code>しておくと読みやすい．</p>
<pre><code>#define N_ALPHABET 26</code></pre></li>
<li><p>出力するとき10文字ごとに改行するには次のように書く方法がある．</p>
<pre><code>for (i = 0; i &lt; 26; i++) {
   printf(&quot;%c %5d&quot;, i + &#39;A&#39;, ucount[i]);
  if (i % 10 == 9) // 10文字ごと
    printf(&quot;\n&quot;);
  else             // それ以外
    printf(&quot; &quot;);
}</code></pre></li>
<li><p>便利な関数（明快入門C，付録A C言語主要関数一覧）：</p>
<ul>
<li><p><code>ctype.h</code>ヘッダファイルで宣言されている文字種別を判定する関数．
<code>isupper</code>関数は，引数の文字<code>c</code>がアルファベット大文字ならば0以外を返し，そうでなければ0を返す．<code>islower</code>関数は，引数の文字<code>c</code>がアルファベット小文字ならば0以外を返し，そうでなければ0を返す．（<code>man isupper</code>などで詳細を確認できる）</p>
<pre><code>int isupper(int c);
int islower(int c);</code></pre></li>
<li><p><code>stdlib.h</code>ヘッダファイルで宣言されている<code>malloc</code>関連の関数．
<code>malloc(size)</code>関数は<code>size</code>バイトのメモリ領域を確保しその領域へのポインタを返す．<code>free(*ptr)</code>関数は<code>malloc</code>関数や<code>calloc</code>関数などで確保したメモリ領域を解放する．<code>calloc(count, size)</code>関数は一要素あたり<code>size</code>バイトで，要素数が<code>count</code>個分のメモリ領域を確保し，その領域に0を書き込んでから，その領域へのポインタを返す．<code>size_t</code>型は符号なし整数．（<code>man malloc</code>などで詳細を確認できる）</p>
<pre><code>void *malloc(size_t size);
void free(void *ptr);
void *calloc(size_t count, size_t size);</code></pre></li>
<li><p>Cygwin64
Terminalで「<code>isuppper</code>というマニュアルはありません」などと表示される場合は
Bb9 の「必携 PC(Windows 10)の演習準備」ページの「Cygwin の man
コマンドの使い方」という項目をみよ.</p></li>
</ul></li>
<li><p>同じ入力で何度も試したい場合は<code>echo</code>コマンドや<code>cat</code>コマンドを使うと何度も同じ文字列を入力しないで済む．<code>echo</code>コマンドの例．</p>
<pre><code>$ echo ABCDE AAA BB C 01234 Z abcde fghij klmno pqrst uvwxy zz | ./letter_histogram</code></pre>
<p><code>cat</code>コマンドの例．入力文字列をファイル input.txt
に保存している．</p>
<pre><code>$ cat input.txt
ABCDE ABCDE AAA BB C 01234 Z
abcde fghij klmno pqrst uvwxy zz
$ cat input.txt | ./letter_histogram</code></pre></li>
</ul>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li
id="fn1"><p>EOFはstdio.hで<code>#define EOF (-1)</code>と定義されています．明快入門Cには，Windowsの終了コードをCtrl+Zと説明していますが，
CygwinターミナルはLinuxに似せて作られているためCtrl+Dが終了コードです．<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn2"><p>Cの絵本「メモリの確保とポインタの活用(1)」には<code>#include &lt;memory.h&gt;</code>と<code>#include &lt;malloc.h&gt;</code>と<code>#include &lt;stdlib.h&gt;</code>の三つのヘッダファイルが必要と書かれているが，Cygwinでは<code>#include &lt;stdlib.h&gt;</code>のみで十分．ターミナルで<code>man malloc</code>を実行して必要なヘッダファイルを確認するのが確実．<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
